<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AfterFlowl的博客</title>
  
  <subtitle>前端程序猿</subtitle>
  <link href="http://afterflowl.github.io/atom.xml" rel="self"/>
  
  <link href="http://afterflowl.github.io/"/>
  <updated>2022-06-22T12:56:42.449Z</updated>
  <id>http://afterflowl.github.io/</id>
  
  <author>
    <name>AfterFlowl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>axios的二次封装</title>
    <link href="http://afterflowl.github.io/2022/06/15/zai-vue-zhong-dui-axios-jin-xing-er-ci-feng-zhuang/"/>
    <id>http://afterflowl.github.io/2022/06/15/zai-vue-zhong-dui-axios-jin-xing-er-ci-feng-zhuang/</id>
    <published>2022-06-15T02:33:18.000Z</published>
    <updated>2022-06-22T12:56:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios-的二次封装"><a href="#axios-的二次封装" class="headerlink" title="axios 的二次封装"></a>axios 的二次封装</h1><p>&#x2F;&#x2F; 使用 axios 用于对数据的请求<br>import axios from ‘axios’<br>&#x2F;&#x2F; 创建 axios 实例<br>const instance &#x3D; axios.create({<br>baseURL: baseURL + version,<br>timeout: 5000<br>})</p><p>&#x2F;&#x2F; 创建请求的拦截器<br>instance.interceptors.request.use(config &#x3D;&gt; {<br>config.headers[‘Authorization’] &#x3D; localStorage.getItem(‘token’)<br>return config<br>}, error &#x3D;&gt; {<br>return Promise.reject(error)<br>})</p><p>&#x2F;&#x2F; 创建响应的拦截器<br>instance.interceptors.response.use(response &#x3D;&gt; {<br>let res &#x3D; null</p><p>&#x2F;&#x2F; 对相应的数据进行过滤<br>if (response.status &#x3D;&#x3D;&#x3D; 200) {<br>if (response.data &amp;&amp; response.data.err &#x3D;&#x3D;&#x3D; 0) {<br>res &#x3D; response.data.data<br>} else if (response.data.err &#x3D;&#x3D;&#x3D; -1) {<br>return alert(‘token 无效’)<br>}<br>} else {<br>return alert(‘请求失败’)<br>}</p><p>return res<br>}, error &#x3D;&gt; {<br>return Promise.reject(error)<br>})</p><p>export default instance</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios-的二次封装&quot;&gt;&lt;a href=&quot;#axios-的二次封装&quot; class=&quot;headerlink&quot; title=&quot;axios 的二次封装&quot;&gt;&lt;/a&gt;axios 的二次封装&lt;/h1&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; 使用 axios 用于对数据的请求&lt;br&gt;</summary>
      
    
    
    
    <category term="进阶" scheme="http://afterflowl.github.io/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="axios" scheme="http://afterflowl.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>简单的loading加载</title>
    <link href="http://afterflowl.github.io/2022/06/15/jian-dan-de-loading-jia-zai/"/>
    <id>http://afterflowl.github.io/2022/06/15/jian-dan-de-loading-jia-zai/</id>
    <published>2022-06-15T02:33:18.000Z</published>
    <updated>2022-06-22T13:13:24.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的-loading-加载"><a href="#简单的-loading-加载" class="headerlink" title="简单的 loading 加载"></a>简单的 loading 加载</h1><p>这边是通过 svg 生成加载图标，通过 animation 生成动画效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">        .loading &#123;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            animation: rotate 2s linear 0s infinite;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .path &#123;</span><br><span class="line">            animation: dash 2s ease-in-out infinite;</span><br><span class="line">            stroke: #00b390;</span><br><span class="line">            stroke-width: 2;</span><br><span class="line">            stroke-dasharray: 90 150;</span><br><span class="line">            stroke-dashoffset: 0;</span><br><span class="line">            stroke-linecap: round;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @keyframes rotate &#123;</span><br><span class="line">            from &#123;</span><br><span class="line">                transform: rotate(0deg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            to &#123;</span><br><span class="line">                transform: rotate(360deg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @keyframes dash &#123;</span><br><span class="line">            0% &#123;</span><br><span class="line">                stroke-dasharray: 1 150;</span><br><span class="line">                stroke-dashoffset: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            50% &#123;</span><br><span class="line">                stroke-dasharray: 90 150;</span><br><span class="line">                stroke-dashoffset: -40px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            100% &#123;</span><br><span class="line">                stroke-dasharray: 90 150;</span><br><span class="line">                stroke-dashoffset: -120px;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;svg class=&quot;loading&quot; viewbox=&quot;25 25 50 50&quot;&gt;</span><br><span class="line">        &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;25&quot; class=&quot;path&quot; fill=&quot;none&quot; /&gt;</span><br><span class="line">    &lt;/svg&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单的-loading-加载&quot;&gt;&lt;a href=&quot;#简单的-loading-加载&quot; class=&quot;headerlink&quot; title=&quot;简单的 loading 加载&quot;&gt;&lt;/a&gt;简单的 loading 加载&lt;/h1&gt;&lt;p&gt;这边是通过 svg 生成加载图标，通过 an</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="svg animation" scheme="http://afterflowl.github.io/tags/svg-animation/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="http://afterflowl.github.io/2022/06/15/fang-dou-he-jie-liu/"/>
    <id>http://afterflowl.github.io/2022/06/15/fang-dou-he-jie-liu/</id>
    <published>2022-06-15T02:33:18.000Z</published>
    <updated>2022-06-22T13:54:33.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖和节流的实现"><a href="#防抖和节流的实现" class="headerlink" title="防抖和节流的实现"></a>防抖和节流的实现</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;clic&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;nihao&quot;&gt;你好&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let clic = document.getElementById(&quot;clic&quot;)</span><br><span class="line">    let nihao = document.getElementById(&quot;nihao&quot;)</span><br><span class="line"></span><br><span class="line">    clic.addEventListener(&#x27;click&#x27;, func())</span><br><span class="line">    let num = 10;</span><br><span class="line">    // 防抖函数</span><br><span class="line">    function debounce(fn, wait) &#123;</span><br><span class="line">        let timer;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            let _this = this;</span><br><span class="line">            console.log(this)</span><br><span class="line">            let args = arguments;</span><br><span class="line">            if (timer) &#123;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                fn.apply(_this, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用</span><br><span class="line">    function func() &#123;</span><br><span class="line">        return debounce(function () &#123;</span><br><span class="line">            num++;</span><br><span class="line">            console.log(num);</span><br><span class="line">        &#125;, 500)</span><br><span class="line">    &#125;</span><br><span class="line">    nihao.onclick = debounce(function () &#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;, 500)</span><br><span class="line">    // clic.onclick = debounce(function () &#123;</span><br><span class="line">    //     num++;</span><br><span class="line">    //     console.log(num);</span><br><span class="line">    // &#125;, 500)</span><br><span class="line">    window.onresize = debounce(function () &#123;</span><br><span class="line">        console.log(&quot;resize&quot;);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    &lt;button id=&quot;wat&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let wat = document.getElementById(&#x27;wat&#x27;);</span><br><span class="line">        wat.addEventListener(&#x27;click&#x27;, func());</span><br><span class="line"></span><br><span class="line">        function func() &#123;</span><br><span class="line">            return debounce(function () &#123;</span><br><span class="line">                console.log(++num);</span><br><span class="line">            &#125;, 3000)</span><br><span class="line">        &#125;</span><br><span class="line">        let num = 111;</span><br><span class="line"></span><br><span class="line">        function debounce(fn, wait) &#123;</span><br><span class="line">            let time = 0;</span><br><span class="line">            return function () &#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                let args = arguments;</span><br><span class="line">                let nowTime = new Date();</span><br><span class="line">                if (nowTime - time &gt; wait) &#123;</span><br><span class="line">                    timer = setTimeout(function () &#123;</span><br><span class="line">                        clearTimeout(timer);</span><br><span class="line">                        fn.apply(_this, args)</span><br><span class="line">                    &#125;, wait)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防抖和节流的实现&quot;&gt;&lt;a href=&quot;#防抖和节流的实现&quot; class=&quot;headerlink&quot; title=&quot;防抖和节流的实现&quot;&gt;&lt;/a&gt;防抖和节流的实现&lt;/h1&gt;&lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="js" scheme="http://afterflowl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>后台管理系统的一些问题及方法(下)</title>
    <link href="http://afterflowl.github.io/2022/04/12/hou-tai-guan-li-xi-tong-de-yi-xie-wen-ti-ji-fang-fa-xia/"/>
    <id>http://afterflowl.github.io/2022/04/12/hou-tai-guan-li-xi-tong-de-yi-xie-wen-ti-ji-fang-fa-xia/</id>
    <published>2022-04-12T12:43:58.000Z</published>
    <updated>2022-06-24T01:45:17.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后台管理系统的一些问题及方法-下"><a href="#后台管理系统的一些问题及方法-下" class="headerlink" title="后台管理系统的一些问题及方法(下)"></a>后台管理系统的一些问题及方法(下)</h2><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><ul><li>工作中最常用的方式是 cors，全称是 Cross Origin Resource Sharing(跨域资源共享）。这种方案前端没有什么工作量，和正常发送请求写法没有区别，工作量在后端。每一次请求，浏览器先以 OPTIONS 请求方式发送一个预请求，通过预请求从而获知服务器对跨源请求支持的 HTTP 方法。在确认服务器允许该跨域请求的情况下，再以实际的 http 请求方法发送真正的请求。</li></ul><p>优点:第一次配好后，之后不管有多少接口和项目，复用就可以了，一劳永逸，而且不管是开发环境和正式环境都能方便的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">//允许访问的地址</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">//允许访问的方式</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">//允许访问的请求头</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">//允许访问的最大时间</span><br></pre></td></tr></table></figure><ul><li>纯前端解决方案（有后端觉得麻烦不想搞）</li></ul><p>在 dev 开发模式下使用 webpack 的 proxy，但是这种方法在生产环境下是不能使用的。在生产环境中需要使用 nginx 进行反向代理。不管是 proxy 和 nginx 的原理都是一样的，通过搭建一个中转服务器来转发请求规避跨域的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//devServer.proxy</span><br><span class="line">proxy:&#123;</span><br><span class="line">&quot;/api&quot;:&#123;</span><br><span class="line">       target&quot;https://other-server.com   //后端API</span><br><span class="line">       pathRewrite:&#123;&quot;^/api&quot;:&quot;&quot;&#125;   //将/api隐藏</span><br><span class="line">       secure：false</span><br><span class="line">       //默认情况下，不接受运行在https上，且使用了无效证书的后端服务器，如果想要接收，设置如上</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//想要对多个路径进行跨域</span><br><span class="line">proxy:[&#123;</span><br><span class="line">    context:[&quot;/auth&quot;,&quot;/api&quot;],</span><br><span class="line">    target:&quot;http://localhost:3000&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>开发环境 生产环境</p><p>cors cors</p><p>proxy nginx</p><ul><li>其他的方法不太推荐，例如 jsonp(利用 script 请求资源，但是只能通过 get 方法）等</li></ul><p>###ESLINT</p><p>代码规范，可以很大程度地避免基本语法错误，也保证了代码的可读性</p><p>配置在.eslintrc.js 上面，</p><p>####取消 ESLint 校验</p><p>如果不想要 ESLint 进行校验（不推荐取消），只需要在 vue.config.js 文件中，进行如下设置 lintOnSave:false;</p><h4 id="Vscode-中配置-ESLint"><a href="#Vscode-中配置-ESLint" class="headerlink" title="Vscode 中配置 ESLint"></a>Vscode 中配置 ESLint</h4><p><a href="https://blog.csdn.net/G0000227/article/details/122093671?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165599450416782389449808%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165599450416782389449808&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-122093671-null-null.142%5Ev21%5Epc_rank_34,157%5Ev15%5Enew_3&utm_term=%E5%A6%82%E4%BD%95%E5%9C%A8vscode%E4%B8%AD%E9%85%8D%E7%BD%AEESLint&spm=1018.2226.3001.4187">详细教程</a></p><p>###自动修复</p><p>npm run lint – –fix</p><h3 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>所有的 Component 文件都是以大写开头（pascalCase），除了 index.vue</p><ul><li><code>@/components/BackToTop/index.vue</code></li><li><code>@/components/Charts/Line.vue</code></li></ul><h4 id="JS-文件"><a href="#JS-文件" class="headerlink" title="JS 文件"></a>JS 文件</h4><p>所有的.js 文件都遵循横线连接(kebab-case)</p><ul><li><code>@/utils/open-window.js</code></li><li><code>@/views/svg-icons/require-icons.js</code></li></ul><h4 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h4><p>在 views 文件下，代表路由的.vue 文件都使用横线连接（kebab-case），代表路由的文件夹也是这种规则</p><ul><li><code>@/views/svg-icons/index.vue</code></li><li><code>@/views/svg-icons/require-icons.js</code></li></ul><p>使用横线连接（kebab-case)来命名 views 主要是出于以下几个考虑</p><ul><li>横线连接（kebab-case)是官方推荐的命名规范之一</li><li>views 的.vue 文件代表的是一个路由，所以需要和 component 进行区分(component 都是大写开头)</li><li>页面的 url 也都是很香连接的，所以路由对应的 view 应该要保持统一，</li><li>没有大小写敏感问题</li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得很大，影响页面加载速度，如果我们把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更高效了</p><p>const Foo&#x3D;（）&#x3D;&gt;import(‘.&#x2F;FOO.vue’)</p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>图表是后台中很常见的需求，我一直使用的都是 ECharts，插件尽量自己用 vue 进行封装。</p><p>首先</p><p>npm install echarts –save</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全部引入</span><br><span class="line">import * as echarts from ’echarts‘；</span><br><span class="line">基于准备好的dom,初始化echarts实例</span><br><span class="line">var myChart = echarts.init(document.getElementId(&#x27;main&#x27;))</span><br><span class="line">或者是通过ref来引入</span><br><span class="line">var myChart = echarts.init(this.refs.xxxx)</span><br><span class="line">var option;</span><br><span class="line">option=(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">    text:&#x27;Echa&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    xAxis;&#123;</span><br><span class="line">    data:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis:&#123;&#125;</span><br><span class="line">    series:[]</span><br><span class="line">&#125;)</span><br><span class="line">option &amp;&amp; myChart.setOption(option);</span><br></pre></td></tr></table></figure><p>data 是远程获取的，或者动态改变 ECharts 配置怎么办</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//第一种  watch  options变化   利用vue的深度watcher，options一有变化就重新setOption</span><br><span class="line">watch:&#123;</span><br><span class="line">   options:&#123;</span><br><span class="line">     handler(options)&#123;</span><br><span class="line">     this.chart.setOption(this,options)</span><br><span class="line">     &#125;,</span><br><span class="line">     deep:true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//第二种   只watch数据的变化，只有数据变化时触发Echarts</span><br><span class="line">watch:&#123;</span><br><span class="line">seriesData(val)&#123;</span><br><span class="line">this,setOptions(&#123;series:val&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好还是结合业务来进行封装，后面就和使用 Echarts 没有区别了，Echarts 的配置项很多，可以多花点时间了解他的 API</p><h3 id="ECharts-图标宽度显示不准确？"><a href="#ECharts-图标宽度显示不准确？" class="headerlink" title="ECharts 图标宽度显示不准确？"></a>ECharts 图标宽度显示不准确？</h3><p>将 ECharts 放到 el-tab 或者 el-dialog 之中，会发现图标的宽度显示没有那么准确，因为 ECharts 本身不是自适应的，当父级容器的宽度发生变化的时候，我们需要手动调用它的.resize()方法，比如<code>el-tab</code>,你可监听 change 事件，当变化时，找到这个图标并调用它的.resize()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      active(val) &#123;</span><br><span class="line">        this.$nextTick(() =&gt; &#123;</span><br><span class="line">          this.$refs.Chart.resize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>在 el-dialog 之中放图表就比较简单，在 dialog 出现之后 init 图表就可以了</p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>一般使用 iconfont.cn 上的图标</p><p>我常用的两种方式：</p><ol><li>将项目用到的图标放到一个项目中，然后下载下来，解压之后，将文件放入到 assest 里面的 font 文件夹里，在 main.js 中引入，</li></ol><p><code>import ‘@/views/font/iconfont.css</code></p><ol start="2"><li><p>单独导出 svg 格式</p><p>将下载后的 svg 文件放入到@&#x2F;icons、svg 文件夹下之后就会自动导入</p></li></ol><p>使用方式</p><p><code>&lt;svg-icon icon-class=&quot;password&quot;/&gt; //icon-class为icon的名字</code></p><p>svg-icon 默认读取其父级的 color，你可以改变父级的 color 或者直接改变 fill 的颜色即可</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>你可以通过<code>npm run preview -- --report</code>来分析 webpack 打包之后的结果，观察各个静态资源的大小，你可以发现占用空间最多的是第三方依赖库。如 Vue&#x2F;element-ui&#x2F;ECharts，</p><p>可以通过 CDN 外链的方式引入第三方库。</p><blockquote><p>TIP</p><p>CDN 引入的方式不能减少代码的体积，这是不可能的，虽然打包的 bundle 小了，但是那部分代码只是被拆出去，用 CDN 的方式引入，如果想减小体积，最高效的就是启用 GZIP</p></blockquote><blockquote><p>缺点：</p><p>引入 CDN 引入的方式等于一些第三方的依赖版本是通过 package.json 来控制的，一些依赖需要手动维护，增加了维护成本。</p><p>webpack 已经做了资源的缓存优化，静态资源的缓存已经做的很好了，我们需要将静态资源上传到自己的 CDN 服务，没有必要使用第三方的 CDN 服务</p></blockquote><h3 id="更换主题和国际化"><a href="#更换主题和国际化" class="headerlink" title="更换主题和国际化"></a>更换主题和国际化</h3><p>参考 element-ui 的指南即可</p><p><a href="https://element.eleme.cn/#/zh-CN/component/i18n">element-ui</a></p><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><h4 id="404"><a href="#404" class="headerlink" title="404"></a>404</h4><p>页面级的错误由 vue-router 统一处理，所有匹配不到正确路由的页面都会进 404 页面</p><blockquote><p>Warning</p><p>404 页面一定要放在最后加载，如果放在 constantRoutes 一同声明了 404，后面 addRoutes 加的路由都会被拦截到 404</p><p>401</p><p>在@&#x2F;permission.js 做了权限控制，没有权限进入该路由的用户会被重定向到 401 页面</p></blockquote><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>项目里面所有的请求都会走 request.js 里面创建的 axios 实例，统一做了错误处理，</p><p>我们可以在 service.interceptors.response response 拦截器之中根据自己的实际业务统一针对不同的状态码或者自定义 code 来做错误处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后台管理系统的一些问题及方法-下&quot;&gt;&lt;a href=&quot;#后台管理系统的一些问题及方法-下&quot; class=&quot;headerlink&quot; title=&quot;后台管理系统的一些问题及方法(下)&quot;&gt;&lt;/a&gt;后台管理系统的一些问题及方法(下)&lt;/h2&gt;&lt;h3 id=&quot;跨域问题&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="进阶" scheme="http://afterflowl.github.io/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="vue" scheme="http://afterflowl.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>后台管理系统的一些问题及方法(上)</title>
    <link href="http://afterflowl.github.io/2022/03/22/hou-tai-guan-li-xi-tong-de-yi-xie-wen-ti-ji-fang-fa-shang/"/>
    <id>http://afterflowl.github.io/2022/03/22/hou-tai-guan-li-xi-tong-de-yi-xie-wen-ti-ji-fang-fa-shang/</id>
    <published>2022-03-22T11:33:18.000Z</published>
    <updated>2022-06-24T01:46:06.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后台管理系统的一些问题及方法（上）"><a href="#后台管理系统的一些问题及方法（上）" class="headerlink" title="后台管理系统的一些问题及方法（上）"></a>后台管理系统的一些问题及方法（上）</h2><h3 id="如何加快首页加载速度"><a href="#如何加快首页加载速度" class="headerlink" title="如何加快首页加载速度"></a>如何加快首页加载速度</h3><ul><li><p>每个单文件使用懒加载</p><p>component:()&#x3D;&gt;import(‘admin&#x2F;hello’)</p></li></ul><h3 id="当两个页面引用的是同一个-component-时，切换不会触发-created-和-mounted-钩子，如何解决？"><a href="#当两个页面引用的是同一个-component-时，切换不会触发-created-和-mounted-钩子，如何解决？" class="headerlink" title="当两个页面引用的是同一个 component 时，切换不会触发 created 和 mounted 钩子，如何解决？"></a>当两个页面引用的是同一个 component 时，切换不会触发 created 和 mounted 钩子，如何解决？</h3><p>官方：可以通过 watch $route 的变化来实现，但是比较麻烦，</p><p>有一个简单的方法就是在 router-view 上加上一个唯一的 key，来保证路由切换的时候会重新渲染触发钩子。</p><p><router-view :key="key"></router-view></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    key() &#123;</span><br><span class="line"></span><br><span class="line">         //只要保证key的唯一性就行，</span><br><span class="line"></span><br><span class="line">​        return this.$route.fullPath;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Router-中-fullpat-和-path-的区别"><a href="#Router-中-fullpat-和-path-的区别" class="headerlink" title="Router 中 fullpat 和 path 的区别"></a>Router 中 fullpat 和 path 的区别</h3><p>path 不能缓存路由跳转后面携带的参数，所以说 path 只能在只有两层数据结构的移动端起作用，</p><p>fullpath 能缓存路由跳转后面携带的参数，刷新后依旧存在，在 pc 端起作用</p><p>###我们在设置中为何需要添加 name 属性？</p><p>当我们使用 keep-alive 中使用 router-view 的时候，如果没有 name 属性，会出现各种问题</p><p>###在后台中路由一般分为几种</p><p>在后台中路由一般分为两种，</p><p>一种是那些不需要动态判断权限的路由，</p><p>一种是那些需要动态判断权限并通过 addRoutes 动态添加的页面，</p><p>这两种路由都使用路由懒加载</p><h3 id="如何实现点击侧边栏刷新当前路由？"><a href="#如何实现点击侧边栏刷新当前路由？" class="headerlink" title="如何实现点击侧边栏刷新当前路由？"></a>如何实现点击侧边栏刷新当前路由？</h3><p>首先添加一个 click 事件，但是因为路由没有改变，所以不会有任何变化，</p><p>所以我们可以给路由的 query 上加一个属性，该属性的值为 new Date()当前时间，确保可以重新刷新 view</p><p>ps：同时我们还需要给 router-view 上加上一个:key 属性</p><p>当然如果觉得这样的页面不是很好看，我们还可以点击事件，跳转页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; fullPath &#125; = this.$route</span><br><span class="line">this.$router.replace(&#123;</span><br><span class="line">  path: &#x27;/redirect&#x27; + fullPath</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 redirect 页面重定向回原始页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    const &#123; params, query &#125; = this.$route</span><br><span class="line">    const &#123; path &#125; = params</span><br><span class="line">    this.$router.replace(&#123; path: &#x27;/&#x27; + path, query &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: function(h) &#123;</span><br><span class="line">    return h() // avoid warning message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><p>用户登录后得到 roles，前端根据 roles 去向后端请求可访问的路由表，从而动态生成可访问页面，之后就是 router.addRoutes 动态挂载到 router 上</p><h3 id="scoped-的作用"><a href="#scoped-的作用" class="headerlink" title="scoped 的作用"></a>scoped 的作用</h3><p>使 css 只作用在当前组件内，使用 scoped 后，父组件的样式不会渗透到子组件里，但是子组件的根节点会同时受父组件的 scoped css 和子组件的 scoped css 影响</p><h3 id="自定义-element-ui-的样式"><a href="#自定义-element-ui-的样式" class="headerlink" title="自定义 element-ui 的样式"></a>自定义 element-ui 的样式</h3><p>因为 element-ui 的样式是全局引入的，所以如果我们想在某个页面内覆盖它的样式就不能加 scoped，但是我们想其他 css 只修改当前页面，就只能在这个页面起作用。方法如下</p><ul><li>在该元素的外面添加一个 class，用命名空间解决问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.article-page &#123;</span><br><span class="line"> /* 你的命名空间 */</span><br><span class="line"> .el-tag &#123;</span><br><span class="line">   /* element-ui 元素*/</span><br><span class="line">   margin-right: 0px;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>深度选择器</p><p>不用预编译 .a &gt;&gt;&gt; .b{}</p><p>使用编译器 &#x2F;deep&#x2F;</p><p>但是目前已经过时，推荐使用 deep（class 名）{}</p></blockquote></li></ul><h3 id="前端请求流程"><a href="#前端请求流程" class="headerlink" title="前端请求流程"></a>前端请求流程</h3><ol><li>UI 组件交互操作</li><li>调用统一管理的 api service 请求函数</li><li>使用封装的 request.js 发送请求</li><li>获取服务端返回</li><li>更新 data</li></ol><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//api/form.js</span><br><span class="line">import request from &#x27;../utils/request&#x27;;</span><br><span class="line">export function fetchList(query)&#123;</span><br><span class="line">    return request(&#123;</span><br><span class="line">    url:&#x27;/from/list&#x27;,</span><br><span class="line">    method:&#x27;get&#x27;,</span><br><span class="line">    params:query</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//views/example/list</span><br><span class="line">import &#123;fetchList&#125; from &#x27;@/api/form&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">    list:null,</span><br><span class="line">    listLoading:true</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    fetchData()&#123;</span><br><span class="line">    this.listLoading = true</span><br><span class="line">    fetchList().then(response)=&gt;&#123;</span><br><span class="line">       this.list = response.data.items</span><br><span class="line">       this.listLoading=false</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="env-文件"><a href="#env-文件" class="headerlink" title="env 文件"></a>env 文件</h3><ul><li><p>env 文件主要的作用是存储环境变量，也就是会随着环境变化的东西，比如数据库的用户名，密码、缓存驱动、时区，还有静态文件的存储路径之类等</p></li><li><p>因为这些信息应该是和环境绑定的，不会随着代码的更新而变化，所以一般不会把.env 文件放到版本控制中</p></li><li><p>关于 env 文件的命名规范：必须以”.env”文件开头</p></li></ul><p>​ .env 全局默认配置文件，不论什么环境都会加载合并</p><p>​ .env.development 开发环境下的配置文件</p><p>​ .env.production 生产环境下的配置文件</p><p>书写要求</p><ul><li>首先 NODE_ENV&#x3D;production 表明什么环境</li><li>属性名必须是 VUE<em>APP</em>开头</li><li><code>NODE_ENV</code> - 会是 “development”、”production” 或 “test” 中的一个。具体的值取决于应用运行的模式。</li><li><code>BASE_URL</code> - 会和 <code>vue.config.js</code> 中的 <code>publicPath</code> 选项相符，即你的应用会部署到的基础路径。</li></ul><p>env 属性的使用</p><p>process.env.VUE_APP_BASE_API</p><h3 id="构建和发布"><a href="#构建和发布" class="headerlink" title="构建和发布"></a>构建和发布</h3><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>当项目开发完毕，运行以下命令打包你的应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br><span class="line">//打包正式环境</span><br><span class="line">npm run build:stage</span><br><span class="line">//打包预发布环境</span><br></pre></td></tr></table></figure><p>构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 xxx.js xxx.css xxx.html 等静态文件</p><p>如果需要自定义构建，比如指定 dist 目录等。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>所有测试环境或者正式环境变量的配置都在.env.development 等.env.xxx 文件中</p><p>会通过 webpack。DefinePlugin 插件注入到全局</p><ul><li>环境变量必须以 VUE<em>APP</em>为开头，如 VUE_APP_API&#x2F;VUE_APP_TITLE</li><li>在代码中获取 process.env.VUE_APP_XXXX</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后台管理系统的一些问题及方法（上）&quot;&gt;&lt;a href=&quot;#后台管理系统的一些问题及方法（上）&quot; class=&quot;headerlink&quot; title=&quot;后台管理系统的一些问题及方法（上）&quot;&gt;&lt;/a&gt;后台管理系统的一些问题及方法（上）&lt;/h2&gt;&lt;h3 id=&quot;如何加快首</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="vue" scheme="http://afterflowl.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript严格模式</title>
    <link href="http://afterflowl.github.io/2022/03/15/javascript-yan-ge-mo-shi/"/>
    <id>http://afterflowl.github.io/2022/03/15/javascript-yan-ge-mo-shi/</id>
    <published>2022-03-15T00:24:48.000Z</published>
    <updated>2022-06-22T13:54:25.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-严格模式"><a href="#JavaScript-严格模式" class="headerlink" title="JavaScript 严格模式"></a>JavaScript 严格模式</h2><p>严格模式（Strict mode）是由 ECMA-262 规范定义的新兴 JavaScript 标准，第五版发布于 2009 年 12 月。旨在改善错误检查功能并且标识可能不会延续到未来 JavaScript 版本的脚本。ES5 严格模式是限制性更强的 JavaScript 变体，它与常规 JavaScript 的语义不同，其分析更为严格。</p><p>目前，除了 IE6-9，其它浏览器均已支持 ES5 严格模式。</p><h3 id="一、严格模式的使用"><a href="#一、严格模式的使用" class="headerlink" title="一、严格模式的使用"></a>一、严格模式的使用</h3><p>严格模式的使用很简单，只有在代码首部加入字符串 “use strict”。有两种应用场景，一种是全局模式，一种是局部模式。</p><h4 id="1）全局模式"><a href="#1）全局模式" class="headerlink" title="1）全局模式"></a>1）全局模式</h4><p>‘use strict’<br>var globalVal &#x3D; 100<br>console.log(globalVal)</p><p>‘use strict’<br>var globalVal &#x3D; 100<br>console.log(globalVal)</p><p>执行后输出了 100，与非严格模式没什么区别。</p><h4 id="2）局部模式"><a href="#2）局部模式" class="headerlink" title="2）局部模式"></a>2）局部模式</h4><p>将”use strict”放到函数内的第一行，如下</p><p>function func() {<br>‘use strict’<br>var localVal &#x3D; 200<br>console.log(localVal)<br>}<br>func()</p><p>function func() {<br>‘use strict’<br>var localVal &#x3D; 200<br>console.log(localVal)<br>}<br>func()</p><p>执行后输出了 200，与非严格模式也没用什么区别。</p><h4 id="3）模块模式"><a href="#3）模块模式" class="headerlink" title="3）模块模式"></a>3）模块模式</h4><p>如果你想定义一个模块或者一个小库，自然采用一个匿名函数自执行是不错的选择</p><p>~function() {<br>“use strict”;</p><p>&#x2F;&#x2F; Define your library strictly…</p><p>}();</p><p>8</p><p>~function() {<br>“use strict”;</p><p>&#x2F;&#x2F; Define your library strictly…</p><p>}();</p><p>“use strict” 的位置是很讲究的，必须在首部。首部指其前面没有任何有效 js 代码。以下都是无效的，将不会触发严格模式。</p><p>a）“use strict” 前有代码</p><p>var width &#x3D; 10<br>‘use strict’<br>globalVar &#x3D; 100</p><p>var width &#x3D; 10<br>‘use strict’<br>globalVar &#x3D; 100</p><p>b）“use strict” 前有个空语句都不行</p><p>;<br>‘use strict’<br>globalVar &#x3D; 100</p><p>或</p><p>function func() {<br>;<br>‘use strict’<br>localVar &#x3D; 200<br>}</p><p>或</p><p>function func() {<br>;’use strict’<br>localVar &#x3D; 200<br>}</p><p>当然，“use strict”前加注释是可以的</p><p>&#x2F;&#x2F; strict mode<br>‘use strict’<br>globalVar &#x3D; 100</p><p>或</p><p>function func() {<br>&#x2F;&#x2F; strict mode<br>‘use strict’<br>localVar &#x3D; 200<br>}<br>func()</p><p>;<br>‘use strict’<br>globalVar &#x3D; 100</p><p>或</p><p>function func() {<br>;<br>‘use strict’<br>localVar &#x3D; 200<br>}</p><p>或</p><p>function func() {<br>;’use strict’<br>localVar &#x3D; 200<br>}</p><p>当然，“use strict”前加注释是可以的</p><p>&#x2F;&#x2F; strict mode<br>‘use strict’<br>globalVar &#x3D; 100</p><p>或</p><p>function func() {<br>&#x2F;&#x2F; strict mode<br>‘use strict’<br>localVar &#x3D; 200<br>}<br>func()</p><h3 id="二、严格模式下的执行限制"><a href="#二、严格模式下的执行限制" class="headerlink" title="二、严格模式下的执行限制"></a>二、严格模式下的执行限制</h3><p>上面举的两个例子，在严格模式中输出与普通模式没用什么区别。下面就不一样了。</p><p>1）不使用 var 声明变量严格模式中将不通过<br>我们知道 JS 是弱类型，宽松的语言。不使用 var 声明的变量默认转为全局变量。但在严格模式中将不允许，会报语法错误。</p><p>‘use strict’<br>globalVal &#x3D; 100</p><p>‘use strict’<br>globalVal &#x3D; 100</p><p>又如全局的 for 循环</p><p>‘use strict’<br>for (i&#x3D;0; i&lt;5; i++) {<br>console.log(i)<br>}</p><p>‘use strict’<br>for (i&#x3D;0; i&lt;5; i++) {<br>console.log(i)<br>}</p><p>这种写法在非严格模式中很危险，i 会不小心溢出成为全局变量。但在严格模式中会报错</p><h4 id="局部模式"><a href="#局部模式" class="headerlink" title="局部模式"></a>局部模式</h4><p>function func() {<br>‘use strict’<br>localVal &#x3D; 200<br>console.log(localVal)<br>}<br>func()</p><p>function func() {<br>‘use strict’<br>localVal &#x3D; 200<br>console.log(localVal)<br>}<br>func()</p><p>因此，严格模式中声明变量务必记得加一个 var。</p><h4 id="2）任何使用’eval’的操作都会被禁止"><a href="#2）任何使用’eval’的操作都会被禁止" class="headerlink" title="2）任何使用’eval’的操作都会被禁止"></a>2）任何使用’eval’的操作都会被禁止</h4><p>‘use strict’<br>var obj &#x3D; {}<br>var eval &#x3D; 3<br>obj.eval &#x3D; 1<br>obj.a &#x3D; eval<br>for (var eval in obj) {}<br>function eval() {}<br>function func(eval) {}<br>var func &#x3D; new Function(‘eval’)</p><p>‘use strict’<br>var obj &#x3D; {}<br>var eval &#x3D; 3<br>obj.eval &#x3D; 1<br>obj.a &#x3D; eval<br>for (var eval in obj) {}<br>function eval() {}<br>function func(eval) {}<br>var func &#x3D; new Function(‘eval’)</p><h4 id="3）eval-作用域"><a href="#3）eval-作用域" class="headerlink" title="3）eval 作用域"></a>3）eval 作用域</h4><p>JS 中作用域有两种，全局作用域和函数作用域。严格模式带来了第三种作用域：eval 作用域，如下</p><p>‘use strict’<br>var a &#x3D; 10<br>eval(‘var a &#x3D; 20; console.log(a)’)<br>console.log(a)</p><p>‘use strict’<br>var a &#x3D; 10<br>eval(‘var a &#x3D; 20; console.log(a)’)<br>console.log(a)</p><p>4）with 被禁用</p><p>‘use strict’<br>with({a:1}) {</p><p>}</p><p>‘use strict’<br>with({a:1}) {</p><p>}</p><h4 id="5）caller-x2F-callee-被禁用"><a href="#5）caller-x2F-callee-被禁用" class="headerlink" title="5）caller&#x2F;callee 被禁用"></a>5）caller&#x2F;callee 被禁用</h4><p>function func() {<br>‘use strict’<br>arguments.callee<br>arguments.caller<br>}<br>func()</p><p>function func() {<br>‘use strict’<br>arguments.callee<br>arguments.caller<br>}<br>func()</p><h4 id="6）对禁止扩展的对象添加新属性会报错"><a href="#6）对禁止扩展的对象添加新属性会报错" class="headerlink" title="6）对禁止扩展的对象添加新属性会报错"></a>6）对禁止扩展的对象添加新属性会报错</h4><p>‘use strict’<br>var obj &#x3D; {}<br>Object.preventExtensions(obj)<br>obj.a &#x3D; 1 &#x2F;&#x2F; 报错</p><p>‘use strict’<br>var obj &#x3D; {}<br>Object.preventExtensions(obj)<br>obj.a &#x3D; 1 &#x2F;&#x2F; 报错</p><h4 id="7）删除系统内置的属性会报错"><a href="#7）删除系统内置的属性会报错" class="headerlink" title="7）删除系统内置的属性会报错"></a>7）删除系统内置的属性会报错</h4><p>‘use strict’<br>delete Object.prototype &#x2F;&#x2F; 报错<br>delete Function.prototype &#x2F;&#x2F; 报错</p><p>‘use strict’<br>delete Object.prototype &#x2F;&#x2F; 报错<br>delete Function.prototype &#x2F;&#x2F; 报错</p><h4 id="8）delete-使用-var-声明的变量或挂在-window-上的变量报错"><a href="#8）delete-使用-var-声明的变量或挂在-window-上的变量报错" class="headerlink" title="8）delete 使用 var 声明的变量或挂在 window 上的变量报错"></a>8）delete 使用 var 声明的变量或挂在 window 上的变量报错</h4><p>‘use strict’<br>var obj &#x3D; {a:1}<br>window.a &#x3D; 1<br>delete obj &#x2F;&#x2F; 报错<br>delete a &#x2F;&#x2F; 报错</p><p>‘use strict’<br>var obj &#x3D; {a:1}<br>window.a &#x3D; 1<br>delete obj &#x2F;&#x2F; 报错<br>delete a &#x2F;&#x2F; 报错</p><h4 id="9）delete-不可删除属性-isSealed-或-isFrozen-的对象时报错"><a href="#9）delete-不可删除属性-isSealed-或-isFrozen-的对象时报错" class="headerlink" title="9）delete 不可删除属性(isSealed 或 isFrozen)的对象时报错"></a>9）delete 不可删除属性(isSealed 或 isFrozen)的对象时报错</h4><p>‘use strict’<br>var obj &#x3D; {a: 1}<br>Object.seal(obj)<br>delete obj.a</p><p>‘use strict’<br>var obj &#x3D; {a: 1}<br>Object.seal(obj)<br>delete obj.a</p><h4 id="10）对一个对象的只读属性进行赋值将报错"><a href="#10）对一个对象的只读属性进行赋值将报错" class="headerlink" title="10）对一个对象的只读属性进行赋值将报错"></a>10）对一个对象的只读属性进行赋值将报错</h4><p>‘use strict’<br>var obj &#x3D; {}<br>Object.defineProperty(obj, ‘a’, {value: 1, writable: false})<br>obj.a &#x3D; 2 &#x2F;&#x2F; 报错</p><p>‘use strict’<br>var obj &#x3D; {}<br>Object.defineProperty(obj, ‘a’, {value: 1, writable: false})<br>obj.a &#x3D; 2 &#x2F;&#x2F; 报错</p><h4 id="11）对象有重名的属性将报错"><a href="#11）对象有重名的属性将报错" class="headerlink" title="11）对象有重名的属性将报错"></a>11）对象有重名的属性将报错</h4><p>‘use strict’<br>var obj &#x3D; {<br>a: 1,<br>a: 2<br>}</p><p>‘use strict’<br>var obj &#x3D; {<br>a: 1,<br>a: 2<br>}</p><p>而在非严格模式中，后面的属性将覆盖前面的属性，即 obj.a 等于 2。</p><h4 id="12）函数有重名的参数将报错"><a href="#12）函数有重名的参数将报错" class="headerlink" title="12）函数有重名的参数将报错"></a>12）函数有重名的参数将报错</h4><p>‘use strict’<br>function func(a, a) {<br>alert(a)<br>}<br>func()</p><p>‘use strict’<br>function func(a, a) {<br>alert(a)<br>}<br>func()</p><p>而在非严格模式中，后面的同名参数将覆盖前面的。</p><h4 id="13）八进制表示法被禁用"><a href="#13）八进制表示法被禁用" class="headerlink" title="13）八进制表示法被禁用"></a>13）八进制表示法被禁用</h4><p>‘use strict’<br>var num &#x3D; 022</p><p>‘use strict’<br>var num &#x3D; 022</p><h4 id="14）arguments-严格定义为参数，不再与形参绑定"><a href="#14）arguments-严格定义为参数，不再与形参绑定" class="headerlink" title="14）arguments 严格定义为参数，不再与形参绑定"></a>14）arguments 严格定义为参数，不再与形参绑定</h4><p>先看非严格模式代码</p><p>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(a) &#x2F;&#x2F; 2<br>}<br>func(1)</p><p>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(a) &#x2F;&#x2F; 2<br>}<br>func(1)</p><p>func 调用时传参为 1，函数内部通过 arguments 修改为 2，此时 alert 的为修改后的 2。 而在严格模式中则不能被修改，如下</p><p>‘use strict’<br>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(a) &#x2F;&#x2F; 1<br>}<br>func(1)</p><p>‘use strict’<br>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(a) &#x2F;&#x2F; 1<br>}<br>func(1)</p><p>显示的严格的为传入的 1。</p><p>其实有点还有点复杂，如果 alert 的是 arguments[0]，实际在严格模式中仍然被修改为 2 了。如下</p><p>‘use strict’<br>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(arguments[0]) &#x2F;&#x2F; 2<br>}<br>func(1)<br>可以参考下 仅 Chrome 中函数实参与形参发生关联</p><p>‘use strict’<br>function func(a) {<br>arguments[0] &#x3D; 2<br>alert(arguments[0]) &#x2F;&#x2F; 2<br>}<br>func(1)<br>可以参考下 仅 Chrome 中函数实参与形参发生关联</p><h4 id="15）函数必须声明在顶层"><a href="#15）函数必须声明在顶层" class="headerlink" title="15）函数必须声明在顶层"></a>15）函数必须声明在顶层</h4><p>我们知道函数声明和函数表达式是两个不同的概念。一般函数声明都在最顶层，ES5 前的 JS 宽松，你可以写在 if 或 for 内（强烈鄙视这种写法）。当然 Firefox 的解析方式与其他浏览器不同，见 SJ9002。而在严格模式中这些写法将直接报错</p><p>‘use strict’<br>if (true) {<br>function func1() { } &#x2F;&#x2F; 语法错误<br>}<br>for (var i &#x3D; 0; i &lt; 5; i++) {<br>function func2() { } &#x2F;&#x2F; 语法错误<br>}</p><p>‘use strict’<br>if (true) {<br>function func1() { } &#x2F;&#x2F; 语法错误<br>}<br>for (var i &#x3D; 0; i &lt; 5; i++) {<br>function func2() { } &#x2F;&#x2F; 语法错误<br>}</p><h4 id="16）ES5-里新增的关键字不能当做变量标示符使用，如-implements-interface-let-package-private-protected-public-static-yield"><a href="#16）ES5-里新增的关键字不能当做变量标示符使用，如-implements-interface-let-package-private-protected-public-static-yield" class="headerlink" title="16）ES5 里新增的关键字不能当做变量标示符使用，如 implements, interface, let, package, private, protected, public, static, yield"></a>16）ES5 里新增的关键字不能当做变量标示符使用，如 implements, interface, let, package, private, protected, public, static, yield</h4><p>‘use strict’<br>var let &#x3D; 10<br>var yield &#x3D; 20</p><p>‘use strict’<br>var let &#x3D; 10<br>var yield &#x3D; 20</p><h4 id="17）call-x2F-apply-的第一个参数直接传入不包装为对象"><a href="#17）call-x2F-apply-的第一个参数直接传入不包装为对象" class="headerlink" title="17）call&#x2F;apply 的第一个参数直接传入不包装为对象"></a>17）call&#x2F;apply 的第一个参数直接传入不包装为对象</h4><p>‘use strict’<br>function func() {<br>console.log(typeof this)<br>}<br>func.call(‘abcd’) &#x2F;&#x2F; string<br>func.apply(1) &#x2F;&#x2F; number</p><p>‘use strict’<br>function func() {<br>console.log(typeof this)<br>}<br>func.call(‘abcd’) &#x2F;&#x2F; string<br>func.apply(1) &#x2F;&#x2F; number</p><p>依次为”string”，”number”。而在非严格模式中 call&#x2F;apply 将对值类型的”abcd”，1 包装为对象后传入，即两次输出都为”object”。</p><h4 id="18）call-x2F-apply-的第一个参数为-null-x2F-undefined-时，this-为-null-x2F-undefined"><a href="#18）call-x2F-apply-的第一个参数为-null-x2F-undefined-时，this-为-null-x2F-undefined" class="headerlink" title="18）call&#x2F;apply 的第一个参数为 null&#x2F;undefined 时，this 为 null&#x2F;undefined"></a>18）call&#x2F;apply 的第一个参数为 null&#x2F;undefined 时，this 为 null&#x2F;undefined</h4><p>这里以 call 来示例</p><p>‘use strict’<br>function func() {<br>console.log(this)<br>}<br>func.call(undefined) &#x2F;&#x2F; undefined<br>func.call(null) &#x2F;&#x2F; null</p><p>‘use strict’<br>function func() {<br>console.log(this)<br>}<br>func.call(undefined) &#x2F;&#x2F; undefined<br>func.call(null) &#x2F;&#x2F; null</p><p>依次是 undefined，null。而非严格模式中则是宿主对象，浏览器里是 window，node.js 环境则是 global。</p><h4 id="19）bind-的第一个参数为-null-x2F-undefined-时，this-为-null-x2F-undefined"><a href="#19）bind-的第一个参数为-null-x2F-undefined-时，this-为-null-x2F-undefined" class="headerlink" title="19）bind 的第一个参数为 null&#x2F;undefined 时，this 为 null&#x2F;undefined"></a>19）bind 的第一个参数为 null&#x2F;undefined 时，this 为 null&#x2F;undefined</h4><p>bind 是 ES5 给 Function.prototype 新增的一个方法，它和 call&#x2F;apply 一样在 function 上直接调用。它返回一个指定了上下文和参数的函数。当它的第一个参数为 null&#x2F;undefined 时，情形和 call&#x2F;apply 一样，this 也为 null&#x2F;undefined。</p><p>‘use strict’<br>function func() {<br>console.log(this)<br>}<br>var f1 &#x3D; func.bind(null)<br>var f2 &#x3D; func.bind(undefined)<br>f1() &#x2F;&#x2F; null<br>f2() &#x2F;&#x2F; undefined</p><p>‘use strict’<br>function func() {<br>console.log(this)<br>}<br>var f1 &#x3D; func.bind(null)<br>var f2 &#x3D; func.bind(undefined)<br>f1() &#x2F;&#x2F; null<br>f2() &#x2F;&#x2F; undefined</p><p>而在非严格模式中输出的都是 window（或 global）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript-严格模式&quot;&gt;&lt;a href=&quot;#JavaScript-严格模式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 严格模式&quot;&gt;&lt;/a&gt;JavaScript 严格模式&lt;/h2&gt;&lt;p&gt;严格模式（Strict mode）是</summary>
      
    
    
    
    <category term="进阶" scheme="http://afterflowl.github.io/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="js" scheme="http://afterflowl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>灵活使用数组排序</title>
    <link href="http://afterflowl.github.io/2021/12/15/ling-huo-shi-yong-shu-zu-pai-xu/"/>
    <id>http://afterflowl.github.io/2021/12/15/ling-huo-shi-yong-shu-zu-pai-xu/</id>
    <published>2021-12-15T04:43:10.000Z</published>
    <updated>2022-06-22T13:41:08.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="灵活使用数组排序"><a href="#灵活使用数组排序" class="headerlink" title="灵活使用数组排序"></a>灵活使用数组排序</h2><p>JavaScript 的数组排序是一个非常常见业务场景</p><p>ECMAScript 为数组提供了一个原生的 sort 函数，今天我们就来好好看看你对 sort 函数究竟了解多少。</p><p>首先我们来看一下 sort 函数的基本信息</p><p>语法：<br>arr.sort([compareFunction])<br>参数:<br>compareFunction [可选]<br>用于数组排序规则的比较函数。如果不含有该参数，数组元素按照转换字符串的各个字符的 Unicode 编码顺序进行排序。<br>compareFunction 参数：<br>firstElement 用于比较的第一个元素<br>secondElement 用于比较的第二个元素<br>返回值:<br>排序后的数组，返回的是当前数组。</p><p>我们先来看看各种排序的应用方式</p><h3 id="没有参数的默认排序"><a href="#没有参数的默认排序" class="headerlink" title="没有参数的默认排序"></a>没有参数的默认排序</h3><p>&#x2F;&#x2F; 当没有参数传入时 默认按照数组转成字符串后的结果每一位的 Unicode 编码进行排序<br>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort();<br>console.log(arr); &#x2F;&#x2F; [26, 31, 311, 33, 4, 40, 43, 54]</p><p>&#x2F;&#x2F; 当没有参数传入时 默认按照数组转成字符串后的结果每一位的 Unicode 编码进行排序<br>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort();<br>console.log(arr); &#x2F;&#x2F; [26, 31, 311, 33, 4, 40, 43, 54]</p><h3 id="升序排列"><a href="#升序排列" class="headerlink" title="升序排列"></a>升序排列</h3><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; a - b);<br>console.log(arr); &#x2F;&#x2F; [4, 26, 31, 33, 40, 43, 54, 311]</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; a - b);<br>console.log(arr); &#x2F;&#x2F; [4, 26, 31, 33, 40, 43, 54, 311]</p><h3 id="降序排列"><a href="#降序排列" class="headerlink" title="降序排列"></a>降序排列</h3><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; b - a);<br>console.log(arr); &#x2F;&#x2F; [311, 54, 43, 40, 33, 31, 26, 4]</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; b - a);<br>console.log(arr); &#x2F;&#x2F; [311, 54, 43, 40, 33, 31, 26, 4]</p><p>好了，看完升序和降序排列以后我们来聊聊排序的规则。<br>如果添加了 compareFunction 那么数组会按该函数的返回值结果进行排序。<br>即 compareFunction(a,b) 表示 a,b 的比较结果，规则如下：<br>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；<br>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。<br>备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；<br>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</p><p>了解了以上排序结果以后我们可以使用 sort 方法颠倒数组的顺序(实现类似于 reverse 方法的效果)</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort(() &#x3D;&gt; -1);<br>console.log(arr); &#x2F;&#x2F; [33, 31, 26, 40, 4, 54, 43, 311]</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort(() &#x3D;&gt; -1);<br>console.log(arr); &#x2F;&#x2F; [33, 31, 26, 40, 4, 54, 43, 311]</p><h3 id="随机排序"><a href="#随机排序" class="headerlink" title="随机排序"></a>随机排序</h3><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; Math.random() - 0.5);<br>console.log(arr); &#x2F;&#x2F; 结果为随机排序</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b) &#x3D;&gt; Math.random() - 0.5);<br>console.log(arr); &#x2F;&#x2F; 结果为随机排序</p><h3 id="按照对象指定的属性值进行升序或降序排列"><a href="#按照对象指定的属性值进行升序或降序排列" class="headerlink" title="按照对象指定的属性值进行升序或降序排列"></a>按照对象指定的属性值进行升序或降序排列</h3><p>var arr &#x3D; [{<br>name: ‘zhangsan’,<br>age: 20<br>}, {<br>name: ‘lisi’,<br>age: 15<br>}, {<br>name: ‘wangwu’,<br>age: 17<br>}, {<br>name: ‘zhaoliu’,<br>age: 23<br>}, {<br>name: ‘fengqi’,<br>age: 31<br>}, {<br>name: ‘xiaoming’,<br>age: 11<br>}];</p><p>function sortby(prop, rev &#x3D; true) {<br>&#x2F;&#x2F; prop 属性名<br>&#x2F;&#x2F; rev 升序降序 默认升序<br>return function(a, b) {<br>var val1 &#x3D; a[prop];<br>var val2 &#x3D; b[prop];<br>return rev ? val1 - val2 : val2 - val1;<br>}<br>}</p><p>arr.sort(sortby(‘age’)); &#x2F;&#x2F; 根据 age 进行升序排列<br>arr.sort(sortby(‘age’,false)); &#x2F;&#x2F; 根据 age 进行降序排列</p><p>var arr &#x3D; [{<br>name: ‘zhangsan’,<br>age: 20<br>}, {<br>name: ‘lisi’,<br>age: 15<br>}, {<br>name: ‘wangwu’,<br>age: 17<br>}, {<br>name: ‘zhaoliu’,<br>age: 23<br>}, {<br>name: ‘fengqi’,<br>age: 31<br>}, {<br>name: ‘xiaoming’,<br>age: 11<br>}];</p><p>function sortby(prop, rev &#x3D; true) {<br>&#x2F;&#x2F; prop 属性名<br>&#x2F;&#x2F; rev 升序降序 默认升序<br>return function(a, b) {<br>var val1 &#x3D; a[prop];<br>var val2 &#x3D; b[prop];<br>return rev ? val1 - val2 : val2 - val1;<br>}<br>}</p><p>arr.sort(sortby(‘age’)); &#x2F;&#x2F; 根据 age 进行升序排列<br>arr.sort(sortby(‘age’,false)); &#x2F;&#x2F; 根据 age 进行降序排列</p><h3 id="我们再来看一些特别的排序方式"><a href="#我们再来看一些特别的排序方式" class="headerlink" title="我们再来看一些特别的排序方式"></a>我们再来看一些特别的排序方式</h3><p>先按奇数升序排列,后按偶数升序排列</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b)&#x3D;&gt;{<br>if(!(a % 2) &amp;&amp; b % 2) return 1; &#x2F;&#x2F; 首先满足条件 a 为偶数,b 为奇数<br>if((a % 2 &amp;&amp; b % 2 || !(a % 2) &amp;&amp; !(b % 2)) &amp;&amp; a &gt; b) return 1; &#x2F;&#x2F; 判断 a b 均为奇数或偶数 且 a &gt; b 即可进行升序排序<br>return -1;<br>});<br>console.log(arr); &#x2F;&#x2F; [31, 33, 43, 311, 4, 26, 40, 54]</p><p>let arr &#x3D; [311,43,54,4,40,26,31,33];<br>arr.sort((a,b)&#x3D;&gt;{<br>if(!(a % 2) &amp;&amp; b % 2) return 1; &#x2F;&#x2F; 首先满足条件 a 为偶数,b 为奇数<br>if((a % 2 &amp;&amp; b % 2 || !(a % 2) &amp;&amp; !(b % 2)) &amp;&amp; a &gt; b) return 1; &#x2F;&#x2F; 判断 a b 均为奇数或偶数 且 a &gt; b 即可进行升序排序<br>return -1;<br>});<br>console.log(arr); &#x2F;&#x2F; [31, 33, 43, 311, 4, 26, 40, 54]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;灵活使用数组排序&quot;&gt;&lt;a href=&quot;#灵活使用数组排序&quot; class=&quot;headerlink&quot; title=&quot;灵活使用数组排序&quot;&gt;&lt;/a&gt;灵活使用数组排序&lt;/h2&gt;&lt;p&gt;JavaScript 的数组排序是一个非常常见业务场景&lt;/p&gt;
&lt;p&gt;ECMAScript </summary>
      
    
    
    
    <category term="进阶" scheme="http://afterflowl.github.io/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="js" scheme="http://afterflowl.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用教程</title>
    <link href="http://afterflowl.github.io/2021/12/02/markdown-shi-yong-jiao-cheng/"/>
    <id>http://afterflowl.github.io/2021/12/02/markdown-shi-yong-jiao-cheng/</id>
    <published>2021-12-02T01:33:18.000Z</published>
    <updated>2022-06-24T01:45:05.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-使用教程"><a href="#Markdown-使用教程" class="headerlink" title="Markdown 使用教程"></a>Markdown 使用教程</h1><h2 id="标题（一共六级标题）"><a href="#标题（一共六级标题）" class="headerlink" title="标题（一共六级标题）"></a>标题（一共六级标题）</h2><p>多少级标题就使用多少个#</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>斜体（文字两端各一个*，或者是各一个下划线_）</p><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p>粗体（文字两端各两个*，或者是下划线_）</p><p><strong>粗体</strong></p><p><strong>粗体</strong></p><p>粗斜体文本(文字两端各三个*，或者是下划线_)</p><p><strong><em>粗斜体文本</em></strong></p><p><strong><em>粗斜体文本</em></strong></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>使用三个星号、减号、底线来设置分隔线，在星号和减号之间加入空格不影响建立分隔线</p><hr><hr><hr><hr><p>###删除线</p><p>删除线的实现使用波浪号（在文字的两端加上两个波浪号）~~</p><p><del>你好</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>通过 html 的<u></u>实现</p><p><u>下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>Markdown 脚注的格式如下:[ ^文本内容]<br>[^要注明的文本]</p><p>##Markdown 列表</p><p>###无序列表</p><p>*，加号+或者减号-作为列表标记，后面要加空格</p><ul><li>你好</li></ul><ul><li>hello</li></ul><ul><li>nihao</li></ul><p>###有序列表使用数字加上.来表示</p><ol><li>第一</li><li>第二</li></ol><p>###列表嵌套</p><p>和正常的使用有序列表和无序列表的规则一致</p><ol><li>第一<ul><li>你好</li><li>你不好</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><p>由内向外在段落开头使用&gt;符号,不用跟空格，第二层写一个&gt;即可</p><blockquote><p>第一层区块</p><blockquote><p>第二层区块</p><blockquote><p>第三层区块</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>与正常使用区块和列表相同即可</p><blockquote><p>区块</p><ol><li>你好</li><li>hello</li><li>nihao</li></ol></blockquote><p>##Markdown 代码</p><p>###如果是段落上的代码或者片段就是使用反引号把他包起来(&#96;)</p><p><code>&lt;script&gt; </code></p><p>###代码区块</p><p>使用四个空格或者一个制表符（tab 键）</p><pre><code>&lt;script&gt;&lt;/script&gt;    &lt;script&gt;    &lt;/script&gt;</code></pre><p>你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    $(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>##Markdown 链接</p><p>链接使用方法<a href=""></a></p><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p><p>这是一个链接<a href="afterflowl.github.io">AfterFlowl 的博客</a></p><h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h4><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><p><a href="1">AfterFlowl 的博客</a></p><p><a href="rootbook">AfterFlowl 的博客</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="title"></p><p><img src="https://pic2.zhimg.com/v2-4d2704ebfd9b58700fbbf3e32200f49b_r.jpg" alt="RUNOOB 图标" title="girlandsea"></p><p>也可以使用 img 来引用图片，并进行设置宽高</p><img src="https://pic2.zhimg.com/v2-4d2704ebfd9b58700fbbf3e32200f49b_r.jpg"><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，</p><table><thead><tr><th>你好</th><th>表头</th></tr></thead><tbody><tr><td>今天</td><td>明天</td></tr></tbody></table><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>在表格上自己设置</p><table><thead><tr><th></th><th align="right"></th></tr></thead><tbody><tr><td></td><td align="right"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown-使用教程&quot;&gt;&lt;a href=&quot;#Markdown-使用教程&quot; class=&quot;headerlink&quot; title=&quot;Markdown 使用教程&quot;&gt;&lt;/a&gt;Markdown 使用教程&lt;/h1&gt;&lt;h2 id=&quot;标题（一共六级标题）&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Markdown" scheme="http://afterflowl.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>css预处理器-less</title>
    <link href="http://afterflowl.github.io/2021/08/27/css-yu-chu-li-qi-less/"/>
    <id>http://afterflowl.github.io/2021/08/27/css-yu-chu-li-qi-less/</id>
    <published>2021-08-27T02:37:06.000Z</published>
    <updated>2022-06-22T13:27:02.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>less 是一种动态样式语言，属于 css 预处理器的范畴，它扩展了 CSS 语言，<br>增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展<br>LESS 既可以在 客户端 上运行 ，也可以借助 Node.js 在服务端运行。</p><p>less 的中文官网：<a href="http://lesscss.cn/">http://lesscss.cn/</a><br>bootstrap 中 less 教程：<a href="http://www.bootcss.com/p/lesscss/">http://www.bootcss.com/p/lesscss/</a></p><h3 id="Less-编译工具"><a href="#Less-编译工具" class="headerlink" title="Less 编译工具"></a>Less 编译工具</h3><p>koala 官网:<a href="http://www.koala-app.com/">www.koala-app.com</a><br>###less 中的注释<br>以&#x2F;&#x2F;开头的注释，不会被编译到 css 文件中<br>以&#x2F;**&#x2F;包裹的注释会被编译到 css 文件中</p><h3 id="less-中的变量"><a href="#less-中的变量" class="headerlink" title="less 中的变量"></a>less 中的变量</h3><p>使用@来申明一个变量：@pink：pink; 1.作为普通属性值只来使用：直接使用@pink 2.作为选择器和属性名：#@{selector 的值}的形式 3.作为 URL：@{url} 4.变量的延迟加载</p><h3 id="less-中的嵌套规则-1-基本嵌套规则"><a href="#less-中的嵌套规则-1-基本嵌套规则" class="headerlink" title="less 中的嵌套规则 1.基本嵌套规则"></a>less 中的嵌套规则 1.基本嵌套规则</h3><p>2.&amp;的使用</p><h3 id="less-中的混合"><a href="#less-中的混合" class="headerlink" title="less 中的混合"></a>less 中的混合</h3><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式 1.普通混合<br> 2.不带输出的混合 3.带参数的混合 4.带参数并且有默认值的混合 5.带多个参数的混合 6.命名参数 7.匹配模式<br>8.arguments 变量</p><h3 id="less-运算"><a href="#less-运算" class="headerlink" title="less 运算"></a>less 运算</h3><p>在 less 中可以进行加减乘除的运算</p><h3 id="less-避免编译"><a href="#less-避免编译" class="headerlink" title="less 避免编译"></a>less 避免编译</h3><h3 id="less-继承"><a href="#less-继承" class="headerlink" title="less 继承"></a>less 继承</h3><p>性能比混合高<br>灵活度比混合低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;less&quot;&gt;&lt;a href=&quot;#less&quot; class=&quot;headerlink&quot; title=&quot;less&quot;&gt;&lt;/a&gt;less&lt;/h1&gt;&lt;p&gt;less 是一种动态样式语言，属于 css 预处理器的范畴，它扩展了 CSS 语言，&lt;br&gt;增加了变量、Mixin、函数等特</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="css less" scheme="http://afterflowl.github.io/tags/css-less/"/>
    
  </entry>
  
  <entry>
    <title>css媒体查询</title>
    <link href="http://afterflowl.github.io/2021/08/12/css-mei-ti-cha-xun/"/>
    <id>http://afterflowl.github.io/2021/08/12/css-mei-ti-cha-xun/</id>
    <published>2021-08-12T02:33:18.000Z</published>
    <updated>2022-06-22T13:23:00.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css3-媒体查询"><a href="#css3-媒体查询" class="headerlink" title="css3 媒体查询"></a>css3 媒体查询</h1><p>css3 媒体查询是响应式方案核心</p><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p>all 所有媒体（默认值）<br>screen 彩色屏幕<br>print 打印预览<br>projection 手持设备<br>tv 电视<br>braille 盲文触觉设备<br>embossed 盲文打印机<br>speech “听觉”类似的媒体设备<br>tty 不适用像素的设备</p><h3 id="媒体属性"><a href="#媒体属性" class="headerlink" title="媒体属性"></a>媒体属性</h3><p>width （可加 max min 前缀）<br>height （可加 max min 前缀）<br>device-width （可加 max min 前缀）<br>device-pixel-ratio（可加 max min 前缀，需要加 webkit 前缀）<br>orientation portrait 竖屏<br>landscape 横屏</p><h3 id="操作符，关键字-only-and-，or-not"><a href="#操作符，关键字-only-and-，or-not" class="headerlink" title="操作符，关键字 (only,and,(，or),not)"></a>操作符，关键字 (only,and,(，or),not)</h3><p>only：<br>防止老旧的浏览器 不支持带媒体属性的查询而应用到给定的样式.<br>@media only screen and (min-width:800px ){<br>规则；<br>规则<br>}<br>@media screen and (min-width:800px ){<br>规则；<br>规则<br>}<br>在老款的浏览器下<br>@media only —&gt; 因为没有 only 这种设备 规则被忽略<br>@media screen —&gt; 因为有 screen 这种设备而且老浏览器会忽略带媒体属性的查询</p><p>建议在每次抒写 media query 的时候带上 only<br>and:<br>连接媒体属性 、连接媒体类型<br>对于所有的连接选项都要匹配成功才能应用规则</p><p>or(,) : 和 and 相似<br>对于所有的连接选项只要匹配成功一个就能应用规则<br>not:取反</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;css3-媒体查询&quot;&gt;&lt;a href=&quot;#css3-媒体查询&quot; class=&quot;headerlink&quot; title=&quot;css3 媒体查询&quot;&gt;&lt;/a&gt;css3 媒体查询&lt;/h1&gt;&lt;p&gt;css3 媒体查询是响应式方案核心&lt;/p&gt;
&lt;h3 id=&quot;媒体类型&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="简单" scheme="http://afterflowl.github.io/categories/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="css" scheme="http://afterflowl.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端英语词汇</title>
    <link href="http://afterflowl.github.io/2021/07/15/qian-duan-ying-wen-ci-hui-biao/"/>
    <id>http://afterflowl.github.io/2021/07/15/qian-duan-ying-wen-ci-hui-biao/</id>
    <published>2021-07-15T02:33:18.000Z</published>
    <updated>2022-06-22T13:17:21.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端英语词汇"><a href="#前端英语词汇" class="headerlink" title="前端英语词汇"></a>前端英语词汇</h1><ol><li>web [web]<br>n. 网；</li><li>hypertext [‘haɪpətekst]<br>n. [计] 超文本（含有指向其它文本文件链接的文本）</li><li>markup [‘mɑːkʌp]<br>n. 标记</li><li>language [‘læŋgwɪdʒ]<br>n. 语言；语言文字；表达能力</li><li>text [tekst]<br>n. [计] 文本；课文；主题;vt. 发短信</li><li>binary [‘baɪnərɪ]<br>adj. [数] 二进制的；二元的，二态的</li><li>body [‘bɒdɪ]<br>n. 身体；主体；大量；团体；主要部分;</li><li>head [hed]<br>n. 头；头痛；上端；最前的部分；理解力;</li><li>title [‘taɪt(ə)l]<br>n. 冠军；标题；头衔；权利；字幕;</li><li>meta [‘metə]<br>pref. 表示“变化”“变换”之义;</li><li>photo [‘fəʊtəʊ]<br>n. 照片</li><li>chrome [krəʊm]<br>n.谷歌浏览器</li><li>explorer [ek’splɔːrə(r)]<br>n. 探险家；</li><li>firefox [faifɔ:ks]<br>n. 火狐浏览器</li><li>shop [ʃɒp]<br>n. 商店；店铺;</li><li>client [‘klaɪənt]<br>n. [经] 客户；顾客；委托人</li><li>browser [‘braʊzə]<br>n. [计] 浏览器；吃嫩叶的动物；浏览书本的人</li><li>doctype<br>n. 文档类型</li><li>quirk [kwɜːk]<br>n. 怪癖；急转；借口</li><li>standard [‘stændəd]<br>n. 标准；水准；旗；度量衡标准</li><li>navigator [‘nævɪgeɪtə]<br>n. 航海家；领航员；驾驶员</li><li>note [nəʊt]<br>n. 笔记；</li><li>copyright [‘kɒpɪraɪt]<br>n. 版权，著作权;</li><li>index [‘ɪndeks]<br>n. 指标；指数；索引；指针;</li><li>element [‘elɪm(ə)nt]<br>n. 元素；要素；原理；成分；自然环境;</li><li>attribute [ə’trɪbjuːt]<br>n. 属性；特质;</li><li>definition [defɪ’nɪʃ(ə)n]<br>n. 定义；[物] 清晰度；解说</li><li>term [tɜːm]<br>n. 术语；学期；期限；条款;</li><li>description [dɪ’skrɪpʃ(ə)n]<br>n. 描述，描写；类型；说明书</li><li>deleted [dɪ’lit]<br>v. 删除，划掉（delete 的过去分词）</li><li>inserted [ɪn’sɜːtɪd]<br>adj. 插入的；[生物] 嵌入的；著生的；附着的</li><li>header [‘hedə]<br>n. 头球；页眉；数据头；收割台</li><li>paragraph [‘pærəgrɑːf]<br>n. 段落；短评；段落符号;</li><li>horizontal [hɒrɪ’zɒnt(ə)l]<br>n. 水平线，水平面；水平位置</li><li>rule [ruːl]<br>n. 统治；规则;</li><li>anchor [‘æŋkə]<br>n. 锚；抛锚停泊；</li><li>abbreviation [əbriːvɪ’eɪʃ(ə)n]<br>n. 缩写；缩写词</li><li>acronym [‘ækrənɪm]<br>n. 首字母缩略词</li><li>address [ə’dres]<br>n. 地址；</li><li>variable [‘veərɪəb(ə)l]<br>n. [数] 变量；</li><li>preformat [pri:’fɔmət]<br>n. [计] 预先格式</li><li>block [blɒk]<br>n. 块；街区；大厦；障碍物;</li><li>quotation [kwə(ʊ)’teɪʃ(ə)n]<br>n.引用语；引证</li><li>strong [strɒŋ]<br>adj. 坚强的；强壮的；</li><li>emphasized [‘ɛmfə,saɪz]<br>v. 强调，着重</li><li>reference [‘ref(ə)r(ə)ns]<br>n. 参考，参照；涉及，提及；参考书目；介绍信；证明书;</li><li>another [ə’nʌðə]<br>adj. 又一，另一；另外的；不同的;</li><li>input [‘ɪnpʊt]<br>n. 投入；输入电路;</li><li>area [‘eərɪə]<br>n. 区域，地区；面积；范围;</li><li>field [fiːld]<br>n. 领域；牧场；旷野；战场；运动场;</li><li>form [fɔːm]<br>n. 表单;</li><li>label [‘leɪb(ə)l]<br>n. 标签；商标；签条;</li><li>document [‘dɒkjʊm(ə)nt]<br>n. 文件，公文；[计] 文档；证件;</li><li>entity [‘entɪtɪ]<br>n. 实体；存在；本质</li><li>enabled [ɪ’nebld]<br>adj. 激活的；可行的;</li><li>disabled [dɪs’eɪbld]<br>v. 使…失去能力（disable 的过去分词）</li><li>checked [tʃekt]<br>adj. 选中的；格子花纹的;</li><li>selection [sɪ’lekʃ(ə)n]<br>n. 选择，挑选；选集；精选品</li><li>name [neɪm]<br>n. 名称，名字；姓名；名誉;</li><li>value [‘væljuː]<br>n. 值；价值；</li><li>gender [‘dʒendə]<br>n. 性别；</li><li>male [meɪl]<br>n. 男人；雄性动物;</li><li>female [‘fiːmeɪl]<br>n. 女人；[动] 雌性动物</li><li>hobby [‘hɒbɪ]<br>n. 嗜好；业余爱好;</li><li>image [‘ɪmɪdʒ]<br>n. 影像；想象；肖像；偶像;</li><li>line [laɪn]<br>n. 路线，航线；排；绳;</li><li>side [saɪd]<br>n. 方面；侧面；旁边;</li><li>empty [‘em(p)tɪ]<br>n. 空车；空的东西</li><li>source [sɔːs]<br>n. 来源；水源；原始资料;</li><li>reset [riː’set]<br>n. 重新设定；重新组合；重排版</li><li>target [‘tɑːgɪt]<br>n. 目标；靶子;</li><li>collapse [kə’læps]<br>n. 倒塌；失败；衰竭</li><li>spacing [‘speɪsɪŋ]<br>n. 间隔；调节间隔；字距;</li><li>cells<br>n. [细胞] 细胞；单元格（cell 的复数）；牢房；小屋;</li><li>table [‘teɪb(ə)l]<br>n. 桌子；表格；平地层;</li><li>lang [læŋ]<br>abbr. 语言（language）;</li><li>type [taɪp]<br>n. 类型，品种；模范；样式;</li><li>item [‘aɪtəm]<br>n. 条款，项目；一则；一件商品（或物品）;</li><li>bold [bəʊld]<br>adj. 黑体的；</li><li>italic [ɪ’tælɪk]<br>n. 斜体字（或字母、数码等）;</li><li>big [bɪg]<br>adj. 大的；重要的；量大的;</li><li>small [smɔːl]<br>adj. 少的，小的；微弱的；几乎没有的；不重要的；幼小的;</li><li>superscript [‘suːpəskrɪpt]<br>n. 上标</li><li>subscript [‘sʌbskrɪpt]<br>n. 下标；脚注</li><li>break [breɪk]<br>vi. 打破；折断；弄坏；削弱;</li><li>center [‘sɛntɚ]<br>n. 中心，中央；中锋；中心点;</li><li>font [fɒnt]<br>n. 字体；字形；泉；洗礼盘，圣水器;</li><li>underlined [‘ʌndɚˌlaɪnd]<br>adj. 下划线的</li><li>strikethrough<br>n. 删除线，加删除线</li><li>fieldset<br>n. 自定义字段；控件组</li><li>legend [‘ledʒ(ə)nd]<br>n. 说明；图例；刻印文字;</li><li>caption [‘kæpʃ(ə)n]<br>n. 标题；字幕；说明；逮捕;</li><li>division [dɪ’vɪʒ(ə)n]<br>n. [数] 除法；部门；分割；师（军队）；赛区</li><li>span [spæn]<br>n. 跨度，跨距；范围;</li><li>ordered [‘ɔːdəd]<br>adj. [数] 有序的；整齐的；安排好的;</li><li>list [lɪst]<br>n. [计] 列表；清单；目录;</li><li>unordered [ʌn’ɔːdəd]<br>adj. 无序的</li><li>id [ɪd]<br>身份证件;</li><li>class [klɑːs]<br>n. 阶级；班级；种类；班；等级;</li><li>black [blæk]<br>n. 黑色；黑人；黑颜料;</li><li>silver [‘sɪlvə]<br>n. 银；银器；银币；银质奖章；餐具；银灰色;</li><li>gray [greɪ]<br>n. 灰色；暗淡的光线;</li><li>white [waɪt]<br>n. 白色；洁白；白种人</li><li>maroon [mə’ruːn]<br>n. 栗色；逃亡黑人奴隶；孤立的人;<br>adj. 栗色的</li><li>red [red]<br>n. 红色，红颜料；赤字;</li><li>purple [‘pɜːp(ə)l]<br>n. 紫色；紫袍;</li><li>fuchsia [‘fjuːʃə]<br>n. 紫红色；[植]倒挂金钟属</li><li>green [griːn]<br>n. 绿色；青春;</li><li>lime [laɪm]<br>n. 石灰；酸橙；绿黄色;</li><li>olive [‘ɒlɪv]<br>n. 橄榄；橄榄树；橄榄色;</li><li>yellow [‘jeləʊ]<br>n. 黄色；黄种人；黄色颜料;</li><li>navy [‘neɪvɪ]<br>n. 海军; 深蓝色的</li><li>blue [bluː]<br>n. 蓝色</li><li>teal [tiːl]<br>n. 茶色</li><li>aqua [‘ækwə]<br>n. 水；溶液；浅绿色;</li><li>orange [‘ɒrɪn(d)ʒ]<br>n. 橙；橙色；桔子</li><li>hack [hæk]<br>vi. 砍;</li><li>foot [fʊt]<br>n. 脚；英尺；步调；末尾;</li><li>main [meɪn]<br>n. 主要部分，要点；体力；总管道;</li><li>menu [‘menjuː]<br>n. 菜单;</li><li>animation [ænɪ’meɪʃ(ə)n]<br>n. 活泼，生气；激励；卡通片绘制</li><li>key [kiː]<br>n. 关键；钥匙;</li><li>background [‘bækgraʊnd]<br>n. 背景；隐蔽的位置;</li><li>color [‘kʌlə(r)]<br>n. 颜色；肤色；颜料；脸色;</li><li>position [pə’zɪʃ(ə)n]<br>n. 位置，方位；职位，工作；姿态；站位;</li><li>repeat [rɪ’piːt]<br>n. 重复；副本;</li><li>size [saɪz]<br>n. 大小；尺寸;</li><li>border [‘bɔːdə]<br>n. 边境；边界；国界;</li><li>bottom [‘bɒtəm]<br>n. 底部；末端；臀部；尽头;</li><li>style [staɪl]<br>n. 风格；时尚；类型；字体;</li><li>width [wɪtθ; wɪdθ]<br>n. 宽度；广度</li><li>left [left]<br>n. 左边；左派；激进分子;</li><li>top [tɒp]<br>n. 顶部，顶端；上部；首席；陀螺;</li><li>outline [‘aʊtlaɪn]<br>n. 轮廓；大纲；概要；略图;</li><li>outset [‘aʊtset]<br>n. 开始；开端</li><li>overflow [əʊvə’fləʊ]<br>n. 充满，洋溢；泛滥；超值；溢值;</li><li>height [haɪt]<br>n. 高地；高度；身高；顶点</li><li>max [mæks]<br>n. 完全；彻底；最大限度；最大量；最大数</li><li>min [min]<br>abbr. 最小值;</li><li>box [bɒks]<br>n. 箱，盒子；包厢；一拳;</li><li>family [‘fæmɪlɪ; -m(ə)l-]<br>n. 家庭；亲属；家族；子女；[生]科；语族；[化]族;</li><li>variant [‘veərɪənt]<br>n. 变体；转化</li><li>weight [weɪt]<br>n. 重量，重力；</li><li>content [kən’tent]<br>n. 内容，目录；满足；容量;</li><li>new [njuː]<br>adj. 新的，新鲜的；更新的；初见的;</li><li>news [njuːz]<br>n. 新闻，消息；新闻报导</li><li>offset [‘ɒfset]<br>n. 偏移;</li><li>margin [‘mɑːdʒɪn]<br>n. 边缘；利润，余裕；页边的空白;</li><li>padding [‘pædɪŋ]<br>n. 填料；垫料;</li><li>clear [klɪə]<br>n. 清除；空隙;</li><li>cursor [‘kɜːsə]<br>n. 光标；（计算尺的）[计] 游标，指针</li><li>display [dɪ’spleɪ]<br>n. 显示；炫耀;</li><li>float [fləʊt]<br>vt. 使漂浮；实行;</li><li>vertical [‘vɜːtɪk(ə)l]<br>n. 垂直线，垂直面</li><li>align [ə’laɪn]<br>vi. 排列；排成一行</li><li>visibility [vɪzɪ’bɪlɪtɪ]<br>n. 能见度，可见性；能见距离；明显性</li><li>layout [‘leɪaʊt]<br>n. 布局；设计；安排；陈列</li><li>decoration [dekə’reɪʃ(ə)n]<br>n. 装饰，装潢；装饰品；奖章</li><li>indent [ɪn’dent]<br>n. 缩进；订货单；凹痕；契约</li><li>transform [træns’fɔːm; trɑːns-; -nz-]<br>vt. 改变，使…变形；转换;</li><li>space [speɪs]<br>n. 空间；太空；距离;</li><li>word [wɜːd]<br>n. [语] 单词；话语；消息；诺言；命令;</li><li>last [lɑːst]<br>n. 末尾，最后；上个；鞋楦（做鞋的模型）;</li><li>emphasis [‘emfəsɪs]<br>n. 重点；强调；加强语气</li><li>trim [trɪm]<br>n. 修剪；整齐；情形;</li><li>justify [‘dʒʌstɪfaɪ]<br>vi. 证明合法；整理版面;</li><li>wrap [ræp]<br>vt. 包；缠绕；隐藏；掩护;</li><li>shadow [‘ʃædəʊ]<br>n. 阴影；影子；幽灵；庇护；隐蔽处;</li><li>origin [‘ɒrɪdʒɪn]<br>n. 起源；原点；出身；开端</li><li>perspective [pə’spektɪv]<br>n. 观点；远景；透视图;</li><li>transition [træn’zɪʃ(ə)n; trɑːn-; -‘sɪʃ-]<br>n. 过渡；转变；[分子生物] 转换；变调</li><li>resize [riː’saɪz]<br>vt. 调整大小</li><li>icon [‘aɪkɒn; -k(ə)n]<br>n. 图标；偶像；肖像，画像；圣像</li><li>footer [‘fʊtə]<br>n. 页脚;</li><li>first [fɜːst]<br>n. 第一；开始；冠军;</li><li>before [bɪ’fɔː]<br>prep. 在…之前，先于;</li><li>after [‘ɑːftə]<br>adv. 后来，以后;</li><li>only [‘əʊnlɪ]<br>adv. 只，仅仅；不料;</li><li>child [tʃaɪld]<br>n. 儿童，小孩，孩子；产物；子孙；幼稚的人；弟子;</li><li>root [ruːt]<br>n. 根；根源；词根；祖先;</li><li>base [beɪs]<br>n. 基础；底部；垒;</li><li>radio [‘reɪdɪəʊ]<br>n. 收音机；无线电广播设备;</li><li>submit [səb’mɪt]<br>vt. 使服从；主张；呈递;<br>vi. 提交；服从</li><li>button [ˈbʌtn]<br>n. 按钮；纽扣;</li><li>select [sɪ’lekt]<br>vt. 挑选；选拔;</li><li>option [‘ɒpʃ(ə)n]<br>n. [计] 选项；选择权；买卖的特权</li><li>cite [saɪt]<br>vt. 引用；传讯；想起；表彰</li><li>canvas [‘kænvəs]<br>n. 帆布;</li><li>code [kəʊd]<br>n. 代码，密码；编码；法典;</li><li>frame [freɪm]<br>n. 框架；结构；[电影] 画面;</li><li>mark [mɑːk]<br>n. 标志；马克；符号；痕迹;</li><li>script [skrɪpt]<br>n. 脚本；手迹；书写用的字母;</li><li>file [faɪl]<br>n. 文件；档案；文件夹；锉刀;</li><li>number [‘nʌmbə]<br>n. 数；（杂志等的）期；号码；数字；算术;</li><li>hidden [‘hɪdn]<br>adj. 隐藏的;</li><li>hide [haɪd]<br>vt. 隐藏；隐瞒；鞭打;</li><li>page [peɪdʒ]<br>n. 页；记录；大事件，时期；男侍者;</li><li>cascading [kæ’skeɪdɪŋ]<br>v. 瀑布般落下；串联；传递信息（cascade 的 ing 形式）</li><li>sheet [ʃiːt]<br>n. 薄片，纸张；薄板；床单;</li><li>extensible [ek’stensɪbl; ɪk’stensɪb(ə)l]<br>adj. 可延长的；可扩张的</li><li>link [lɪŋk]<br>vt. 连接，连结；联合，结合;</li><li>auto [‘ɔːtəʊ]<br>n. 自动;</li><li>banner [‘bænə]<br>n. 旗帜，横幅；标语;</li><li>url [,ju: ɑ:r ‘el]<br>abbr. 全球资源定位器（Uniform Resource Locator）;</li><li>div [dɪv]<br>abbr. 分开（divide）；区分（division）;</li><li>section [‘sekʃ(ə)n]<br>n. 截面；部分；部门；地区；章节;</li><li>container [kən’teɪnə]<br>n. 集装箱；容器</li><li>sprite [spraɪt]<br>n. 妖精，精灵；鬼怪；调皮鬼</li><li>region [‘riːdʒ(ə)n]<br>n. 地区；范围；部位</li><li>mast [mɑːst]<br>n. 桅杆；柱；橡树果实;</li><li>javascript[‘dʒɑ:və,skrɪpt]<br>n. 基于对象和事件驱动的客户端脚本语言</li><li>alert [ə’lɜːt]<br>vt. 警告；使警觉，使意识到</li><li>write [raɪt]<br>vi. 写，写字；写作，作曲；写信</li><li>console [kən’səʊl]<br>n. [计] 控制台；[电] 操纵台</li><li>log [lɒg]<br>日志， 记录</li><li>keyword [‘ki:wə:d]<br>关键字</li><li>null [nʌl]<br>空, 空的</li><li>memory [‘mem(ə)rɪ]<br>内存, 记忆</li><li>type [taɪp]<br>类型</li><li>Number [‘nʌmbə]<br>数字， 数值</li><li>String [strɪŋ]<br>字符串</li><li>Boolean [‘bu:liən]<br>布尔</li><li>true [truː]<br>真的</li><li>false [fɔːls; fɒls]<br>假的</li><li>undefined [ʌndɪ’faɪnd]<br>未定义的; 未赋值的</li><li>function [‘fʌŋ(k)ʃ(ə)n]<br>函数; 功能</li><li>Object [‘ɒbdʒɪkt]<br>对象</li><li>array [ə’reɪ]<br>数组</li><li>infinity [ɪn’fɪnɪtɪ]<br>无穷；无限大</li><li>cast [kɑːst]<br>转换</li><li>expression [ɪk’spreʃ(ə)n; ek-]<br>表达式</li><li>statement [‘steɪtm(ə)nt]<br>语句</li><li>parse [pɑːz]<br>解析</li><li>int [int] integer [‘intidʒə]<br>整数</li><li>float [fləʊt]<br>浮点数</li><li>instance [‘ɪnst(ə)ns]<br>实例</li><li>NaN [næn]<br>Not a Number： 不是一个数字</li><li>if [ɪf]<br>如果；条件</li><li>else [els]<br>别的；其他的</li><li>switch [swɪtʃ]<br>开关；转换</li><li>case [keɪs]<br>情况；实例</li><li>break [breɪk]<br>打破；折断</li><li>default [dɪ’fɔːlt]<br>默认的</li><li>while [waɪl]<br>当……的时候</li><li>continue [kən’tɪnjuː]<br>继续</li><li>declare [dɪ’kleə]<br>声明</li><li>module [‘mɒdjuːl]<br>模块；组件</li><li>call [kɔːl]<br>打电话， 调用</li><li>scope [skəʊp]<br>范围</li><li>return [rɪ’tɜːn]<br>返回</li><li>argument [‘ɑːgjʊm(ə)nt]<br>参数，实参</li><li>parameter [pə’ræmɪtə]<br>参数; 形参</li><li>global [‘gləʊb(ə)l]<br>全局的</li><li>local [‘ləʊk(ə)l]<br>局部的， 本地的</li><li>destroy [dɪ’strɒɪ]<br>销毁</li><li>value [‘væljuː]<br>值</li><li>DOM [dɑm]<br>Document Object Model 文档对象模型</li><li>BOM<br>Browser Object Model 浏览器对象模型</li><li>window [‘wɪndəʊ]<br>窗；窗口</li><li>property [‘prɒpətɪ]<br>属性</li><li>method [‘meθəd]<br>方法</li><li>constructor [kənˈstrʌktə(r)]<br>构造函数；构造器</li><li>element [‘elɪm(ə)nt]<br>元素</li><li>index [‘ɪndeks]<br>下标， 索引</li><li>length [leŋθ]<br>长度</li><li>push [pʊʃ]<br>推, 添加到最后</li><li>shift [ʃɪft]<br>添加为第一个</li><li>pop [pɒp]<br>取出</li><li>unshift [,ʌn’ʃift]<br>删除第一个</li><li>join [dʒɒɪn]<br>连接</li><li>reverse [rɪ’vɜːs]<br>颠倒；倒转</li><li>sort [sɔːt]<br>排序</li><li>concat<br>合并</li><li>slice [slaɪs]<br>取出部分</li><li>filter [‘fɪltə]<br>过滤</li><li>prototype [‘prəʊtətaɪp]<br>原型</li><li>own [əʊn]<br>自己的</li><li>splice [splaɪs]<br>拼接</li><li>apply [ə’plaɪ]<br>申请；应用到…</li><li>time [taɪm]<br>时间</li><li>millisecond [‘mɪlɪsek(ə)nd]<br>n. 毫秒</li><li>GMT [,dʒi: em ‘ti:]<br>格林威治标准时间</li><li>Regular [‘regjʊlə]<br>正规的， 正常的</li><li>Regular Expression<br>正则表达式</li><li>pattern [‘pæt(ə)n]<br>模式</li><li>modifier [‘mɒdɪfaɪə]<br>修饰语</li><li>exec [ɪg’zek; eg-]<br>执行</li><li>search [sɜːtʃ]<br>查找</li><li>match [mætʃ]<br>匹配</li><li>replace [rɪ’pleɪs]<br>取代，代替</li><li>Range [reɪn(d)ʒ]<br>范围；幅度</li><li>eval [ɪ’væl]<br>重新运算求出参数的内容</li><li>Reference [‘ref(ə)r(ə)ns]<br>引用， 参考</li><li>catch [kætʃ]<br>捕捉；捕获</li><li>fix [fɪks]<br>固定</li><li>digits [‘didʒits]<br>位数</li><li>substring [‘sʌb,striŋ]<br>子串；子链</li><li>LowerCase [,ləʊə’keɪs]<br>小写字母</li><li>UpperCase [‘ʌpə’keɪs]<br>大写字母</li><li>Location [lə(ʊ)’keɪʃ(ə)n]<br>位置, 定位</li><li>Screen [skriːn]<br>屏幕</li><li>History [‘hɪst(ə)rɪ]<br>历史</li><li>parent [‘peər(ə)nt]<br>父亲</li><li>confirm [kən’fɜːm]<br>确认</li><li>prompt [prɒm(p)t]<br>提示</li><li>Timeout [taim’aut]<br>超时</li><li>Interval [‘ɪntəv(ə)l]<br>间隔；间歇</li><li>Scroll [skrəʊl]<br>滚动</li><li>open [‘əʊp(ə)n]<br>打开</li><li>close [kləʊs]<br>关闭</li><li>node [nəʊd]<br>节点</li><li>anchor [‘æŋkə]<br>锚；抛锚</li><li>cookie [‘kʊkɪ]<br>饼干；小甜点</li><li>tag [tæg]<br>标签</li><li>create [kriː’eɪt]<br>创造，创建</li><li>child [tʃaɪld]<br>孩子</li><li>first [fɜːst]<br>第一个</li><li>last [lɑːst]<br>最后一个</li><li>next [nekst]<br>下一个</li><li>previous [‘priːvɪəs]<br>上一个</li><li>sibling [‘sɪblɪŋ]<br>兄弟姊妹</li><li>check [tʃek]<br>勾选</li><li>append [ə’pend]<br>附加上</li><li>insert [ɪn’sɜːt]<br>插入；嵌入</li><li>remove [rɪ’muːv]<br>移除</li><li>inner [ɪnə]<br>内部的</li><li>event [ɪ’vent]<br>事件</li><li>CallBack [‘kɔːlbæk]<br>回调</li><li>blur [blɜː]<br>失去焦点</li><li>focus [‘fəʊkəs]<br>n. 焦点；中心；清晰；焦距</li><li>change [tʃeɪn(d)ʒ]<br>变化</li><li>click [klɪk]<br>单击；点击</li><li>load [ləʊd]<br>加载</li><li>press [pres]<br>压；按</li><li>mouse [maʊs]<br>鼠标</li><li>over [‘əʊvə]<br>在…之上</li><li>listener [‘lɪs(ə)nə]<br>监听器</li><li>attach [ə’tætʃ]<br>附加；附属</li><li>capture [‘kæptʃə]<br>捕获</li><li>bubble [‘bʌb(ə)l]<br>冒泡</li><li>cancel [‘kæns(ə)l]<br>取消</li><li>expires [ɪk’spaɪəz]<br>有效期</li><li>session [‘seʃ(ə)n]<br>会话</li><li>prevent [prɪ’vent]<br>阻止, 防止</li><li>wheel [wiːl]<br>滚轮</li><li>closure [‘kləʊʒə]<br>闭包</li><li>context [‘kɒntekst]<br>环境；上下文</li><li>selector [sɪ’lektə]<br>选择器</li><li>offset [‘ɒfset]<br>偏移</li><li>visible [ˈvɪzəbl]<br>可见</li><li>find [faɪnd]<br>查找</li><li>show [ʃəʊ]<br>显示</li><li>toggle [‘tɒg(ə)l]<br>开关</li><li>slide [slaɪd]<br>平滑的</li><li>fadein<br>n. 渐显；渐明</li><li>animate [‘ænɪmeɪt]<br>动画</li><li>delay [dɪ’leɪ]<br>延迟</li><li>serialize [‘siəriəlaiz]<br>序列化</li><li>extends [ɪk’stendz; ek-]<br>继承</li><li>support [sə’pɔːt]<br>支持</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端英语词汇&quot;&gt;&lt;a href=&quot;#前端英语词汇&quot; class=&quot;headerlink&quot; title=&quot;前端英语词汇&quot;&gt;&lt;/a&gt;前端英语词汇&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;web [web]&lt;br&gt;n. 网；&lt;/li&gt;
&lt;li&gt;hypertext [‘haɪpətek</summary>
      
    
    
    
    <category term="基础" scheme="http://afterflowl.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="grammer" scheme="http://afterflowl.github.io/tags/grammer/"/>
    
  </entry>
  
</feed>
